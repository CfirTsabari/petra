mod configuration;
use petra_backend_core::{format, Name, SimpleLanguageBackend};
use std::io::Write;

pub use configuration::PetraGolangConfiguration;

#[derive(
    SimpleLanguageBackend, format::PetraFormatFooter, format::PetraFormatAutoGeneratedComment,
)]
pub struct PetraGolangBackend {
    config: PetraGolangConfiguration,
}

impl PetraGolangBackend {
    #[must_use]
    pub const fn new(config: PetraGolangConfiguration) -> Self {
        Self { config }
    }
}

impl format::PetraFormatHeader for PetraGolangBackend {
    fn format<T: Write>(&mut self, writer: &mut T) -> std::io::Result<()> {
        writeln!(writer, "package {}\n", self.config.get_package_name())
    }
}
impl format::PetraFormatI64 for PetraGolangBackend {
    fn format<T: Write>(&mut self, name: &Name, data: i64, writer: &mut T) -> std::io::Result<()> {
        let name = name.to_pascal_case();
        writeln!(writer, "const {name} = {data}")
    }
}
impl format::PetraFormatString for PetraGolangBackend {
    fn format<T: Write>(&mut self, name: &Name, data: &str, writer: &mut T) -> std::io::Result<()> {
        let name = name.to_pascal_case();
        writeln!(writer, "const {name} = \"{data}\"")
    }
}
impl format::PetraFormatLineComment for PetraGolangBackend {
    fn format<T: Write>(&mut self, comment: &str, writer: &mut T) -> std::io::Result<()> {
        writeln!(writer, "// {comment}")
    }
}
impl format::PetraFormatMultiLineComment for PetraGolangBackend {
    fn format<T: Write>(&mut self, comment: &str, writer: &mut T) -> std::io::Result<()> {
        writeln!(writer, "\n/*")?;
        for line in comment.lines().filter(|&x| !x.trim().is_empty()) {
            writeln!(writer, "{line}")?;
        }
        writeln!(writer, "*/")
    }
}
