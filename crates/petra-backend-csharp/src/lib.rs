mod configuration;
use petra_backend_core::format;
use petra_backend_core::Name;
use petra_backend_core::SimpleLanguageBackend;

pub use configuration::PetraCSharpConfiguration;
const SPACE_4: &str = "    ";
#[derive(SimpleLanguageBackend)]
pub struct PetraCSharpBackend {
    config: PetraCSharpConfiguration,
}

impl PetraCSharpBackend {
    #[must_use]
    pub const fn new(config: PetraCSharpConfiguration) -> Self {
        Self { config }
    }
}

impl format::PetraFormatHeader for PetraCSharpBackend {
    fn format(&self) -> Option<Vec<u8>> {
        let data = format!(
            "namespace {};\npublic static class {}\n{{\n",
            self.config.get_namespace_name(),
            self.config.get_class_name()
        );
        Some(data.into_bytes())
    }
}
impl format::PetraFormatAutoGeneratedComment for PetraCSharpBackend {
    fn format(&self) -> Option<Vec<u8>> {
        Some(configuration::AUTO_GENERATED_COMMENT.to_vec())
    }
}

impl format::PetraFormatFooter for PetraCSharpBackend {
    fn format(&self) -> Option<Vec<u8>> {
        Some(b"}\n".to_vec())
    }
}

impl format::PetraFormatI64 for PetraCSharpBackend {
    fn format(&self, name: &Name, data: i64) -> Vec<u8> {
        let name: String = name.to_pascal_case();
        let data = format!("{SPACE_4}public const long {name} = {data};\n");
        data.into_bytes()
    }
}
impl format::PetraFormatString for PetraCSharpBackend {
    fn format(&self, name: &Name, data: &str) -> Vec<u8> {
        let name = name.to_pascal_case();
        let data = format!("{SPACE_4}public const string {name} = \"{data}\";\n");
        data.into_bytes()
    }
}
impl format::PetraFormatLineComment for PetraCSharpBackend {
    fn format(&self, comment: &str) -> Vec<u8> {
        [SPACE_4.as_bytes(), b"// ", comment.as_bytes(), b"\n"].concat()
    }
}
impl format::PetraFormatMultiLineComment for PetraCSharpBackend {
    fn format(&self, comment: &str) -> Vec<u8> {
        [b"/*", comment.as_bytes(), b"*/\n"].concat()
    }
}
